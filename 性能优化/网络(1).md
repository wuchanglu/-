# 网络

因为 DNS 解析和 TCP 连接这两个步骤前端可以做的努力非常有限，所以主要核心在 HTTP 连接方面

1. 减少请求次数
2. 减少单次请求所花费的时间

这两点直直指向日常开发中非常常见的操作---没错，这就是我们每天用构建工具在做的事情。而时下最主流的构建工具无疑是 webpack，所以我们的主要任务就是围绕业界霸主 webpack 来做文章。

## webpack

### webpack 的优化瓶颈

1. webpack 的构建过程太花时间
2. webpack 打包结果体积太大

#### webpack 优化方案

1. 不要让 loader 做太多事情（避免不必要的转译）
   最常见的优化方式是，用 include 或 exclude 来帮我们避免不必要的转译
2. 第三方库编译文件缓存
   不常变动的第三方库通过 DllPlugin 进行处理
3. 将 loader 由单进程转为多进程
   使用 Happypack
4. 构建结果体积压缩
   可以使用 webpack-bundle-analyzer 插件来看构建结果
5. 拆分资源
6. 删除冗余代码
7. 按需加载
   一次不加载完所有的文件内容，只加载此刻需要用到的那部分（会提前做拆分）  
   当需要更多内容时，再对用到的内容进行即时加载

## Gzip 压缩原理

`什么是HTTP压缩`

```
HTTP 压缩是一种内置到网页服务器和网页客户端中以改进传输速度和带宽利用率的方式。在使用 HTTP 压缩的情况下，HTTP 数据在从服务器发送前就已压缩：兼容的浏览器将在下载所需的格式前宣告支持何种方法给服务器；不支持压缩方法的浏览器将下载未经压缩的数据。最常见的压缩方案包括 Gzip 和 Deflate。
```

总结下来就是，浏览器请求之前告诉服务器我支持这个格式的 http 压缩，你用这个方法把文件压缩给我，我到时候用对应的解压方式解压

`Gzip背后原理`
在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小。根据这个原理，文件中代码的重复率越高，那么压缩的效率就越高，使用 Gzip 的收益就越大，反之亦然

### webpack 的 Gzip 和服务端的 Gzip

服务端的 Gzip 压缩以为需要占用 cpu 资源和消耗时间，简单地说就是以服务器的开销和浏览器解析的开销为代价，去省下传输中的时间开销  
Webpack 中 Gzip 压缩操作的存在，事实上就是为了在构建过程中去做一部分服务器的工作，为服务器分压
