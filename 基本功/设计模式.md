# 设计模式

> 设计模式总的来说是一个抽象的概念，前人通过无数次的实践总结出的一套写代码的方式，通过这种方式写的代码可以让别人更加容易阅读、维护以及复用

## 工厂模式

案例代码：

```js
class Man {
  constructor(name) {
    this.name = name;
  }
  alertName() {
    alert(this.name);
  }
}

class Factory {
  static create(name) {
    return new Man(name);
  }
}

Factory.create("yck").alertName();
```

隐藏创建实例的复杂度，只提供一个接口，用户只负责传递需要的参数，无需关心参数怎么使用，内部逻辑，最终返回创建的实例。

## 单例模式

单例模式的核心就是保证全局只有一个对象可以访问。使用场景如全局缓存、全局状态管理等只需要一个对象的情况  
案例代码：

```js
class Singleton {
  constructor() {}
}

Singleton.getInstance = (function () {
  let instance;
  return function () {
    if (!instance) {
      instance = new Singleton();
    }
    return instance;
  };
})();

let s1 = Singleton.getInstance();
let s2 = Singleton.getInstance();
console.log(s1 === s2); // true
```

## 适配器模式

案例代码：

```js
class Plug {
  getName() {
    return "港版插头";
  }
}

class Target {
  constructor() {
    this.plug = new Plug();
  }
  getName() {
    return this.plug.getName() + " 适配器转二脚插头";
  }
}

let target = new Target();
target.getName(); // 港版插头 适配器转二脚插头
```

适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。

## 装饰模式

装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。

案例代码：

```js
// ES7中的装饰器语法
function readonly(target, key, descriptor) {
  descriptor.writable = false;
  return descriptor;
}

class Test {
  @readonly
  name = "yck";
}

let t = new Test();

t.yck = "111"; // 不可修改
```

## 代理模式

代理模式是为了控制对象的访问，不让外部直接访问对象。  
案例代码：

```js
// 事件代理
<ul id="ul">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
</ul>
<script>
    let ul = document.querySelector('#ul')
    ul.addEventListener('click', (event) => {
        console.log(event.target);
    })
</script>
```

## 发布-订阅模式

发布订阅模式也叫做观察者模式，通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。  
案例代码：

```js
const obj = { name: "a", sex: "boy" };
function Watch(target) {
  Object.keys(target).forEach((key) => {
    const privateKey = Symbol(key);
    target[privateKey] = target[key];
    Object.defineProperty(target, key, {
      get() {
        console.log(key + ":我被获取了");
        return target[privateKey];
      },
      set(val) {
        target[privateKey] = val;
        console.log(key + ":我被修改了");
        return target[privateKey];
      },
    });
  });
}
Watch(obj);
obj.name;
obj.sex = "girl";
```

## 外观模式

外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用。  
案例代码：

```js
// 实现一个兼容多种浏览器的添加事件方法
function addEvent(elm, evType, fn, useCapture) {
  if (elm.addEventListener) {
    elm.addEventListener(evType, fn, useCapture);
    return true;
  } else if (elm.attachEvent) {
    var r = elm.attachEvent("on" + evType, fn);
    return r;
  } else {
    elm["on" + evType] = fn;
  }
}
```
